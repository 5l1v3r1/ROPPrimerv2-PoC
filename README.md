# ROPPrimerv2-PoC
My ROPPrimer v2 Proof of Concepts

level0: I messed around with this level a lot at first I had a ROP chain going of about 3 calls added into memory but got it down to one call that returns to shellcode by leveraging the mapped memory segment. I was able to leverage it because my buffer is written to it when the call to gets() reads in my payload. I then take advantage of a crash to initiate a ROP sequence. I call mprotect and make the mapped section of memory RWX then return to the shellcode that was placed on the mapped segment from the gets() call earlier. Shell popped!

level1: For this level I chose to shake it up and instead of getting a shell I read the flag. I used 3 links in my ROP chain the first ROP to the open call to open the flag file. The second ROP to the read call to read the file onto the stack. Finally the third ROP to the write call to write the flag buffer placed on the stack (52 bytes) to the file descriptor for the socket within the binary causing the flag to be sent over the connection to my machine.

level2: Decided to pop a shell for this level. In this level the main challenge objective was that there was a strcpy() call which meant I couldn't use \x00 or \x0a bytes so this caused me to have to iterate using pop and inc and dec instructions. Once I had all the registers setup I skipped to the 13th instruction of the mprotect libc wrapper where eax was set for me to the correct syscall number. Then called the software interrupt \x80. This made the stack RWX I then added shellcode to the end and some NOPs to assist the instruction pointer to execute my shellcode popping a root shell.
